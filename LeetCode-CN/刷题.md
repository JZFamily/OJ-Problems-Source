>create by jzf@2018/06/20

[TOC]
# 作业
[TOC]
## 627. 交换工资 @2018/06/20

### jzf :517ms
```c++
update salary 
    set sex = case when sex ='m' then 'f' else 'm' end;
```
### kiritow:563ms
```c++
    update salary set sex = case sex
    when 'f' then 'm'
    when 'm' then 'f'
    end
```


## 3. 无重复字符的最长子串 @2018/06/20

### 北河  
    
* 第一版 :392ms
```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        map<char, short> v;
        int max_num = 0;
        for (int i = 0; i < s.size(); ++i) {
            if (v.find(s[i]) != v.end()) {
                if (max_num < v.size()) {
                    max_num = v.size();
                }
                i = v.find(s[i])->second + 1;
                v.clear();
            }
            if (i >= s.size()) {
                break;
            }
            v[s[i]] = i;
            if (max_num < v.size()) {
                max_num = v.size();
            }
        }
        return max_num;
    }
};

```
* 第2版 :32ms
```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        map<char, short> v;
        int max_num = 0;
        for (int i = 0; i < s.size(); ++i) {
            if (v.find(s[i]) != v.end()) {
                if (max_num < v.size()) {
                    max_num = v.size();
                }
                ++i;
                while (i < s.size()) {
                    if (v.find(s[i]) != v.end()) {
                        ++i;
                        continue;
                    }
                    --i;
                    break;
                }
                if (i >= s.size()) {
                    return max_num;
                }
                i = v.find(s[i])->second + 1;
                v.clear();
            }
            if (i >= s.size()) {
                break;
            }
            v[s[i]] = i;
            if (max_num < v.size()) {
                max_num = v.size();
            }
        }
        return max_num;
    }
};
```
### jzf 	:252 ms  8
```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int num =1;
        int max =0;
        if(s.length()==1)
        {
            return 1;
        }
        for(size_t i =0;i<s.length();i++)
        {
            
            for(size_t j=i+1;j<s.length();j++)
            {
                int flag =0;
                for(size_t k =i;k<j;k++)
                {
                    if(s[j]==s[k])   
                    {
                        flag =1;
                        break;
                    }
                    num++;
                }
                    if(num>max)
                    {
                        max =num;
                    }
                if(flag ==1)
                {
                    break;
                }
                num =1;
            }
             num =1;
        }
        return max;
    }
};
```
###  puck  :544ms  2
```c++
#ifndef SOLUTION_H
#define SOLUTION_H

#include <algorithm>
#include <string>
#include <set>
using std::string;
class Solution
{
  public:
    int lengthOfLongestSubstring(string s)
    {
        int result{};
        for (std::size_t i{}; i < s.size(); ++i)
        {
            string tmp_str = s.substr(i);
            int cu_length{};
            std::set<char> set_except;
            
            for (auto ch : tmp_str)
            {
                if (set_except.end() == set_except.find(ch))
                {
                    set_except.insert(ch);
                    ++cu_length;
                }
                else
                {
                    break;
                }
            }

            result = std::max(result, cu_length);
        }

        return result;
    }
};

#endif
```
### kiritow  ：24ms  2
```c++
#include <cstdlib>
#include <cstring>
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int sz = s.size();
        int bin[256];
        int maxlen = 0;
        int clen = 0;
        int L = 0;
        while (L < sz)
        {
            memset(bin, 0, sizeof(int) * 256);
            int i;
            for (i = L; i < sz; i++)
            {
                if (bin[s[i]])
                {
                    maxlen = clen > maxlen ? clen : maxlen;
                    clen = 0;
                    L++;
                    break;
                }
                else
                {
                    bin[s[i]] = 1;
                    clen++;
                }
            }
            if (i == sz)
            {
                maxlen = clen > maxlen ? clen : maxlen;
                break;
            }
        }
        return maxlen;
    }
};
```
### 知识点
   
    桶排序
    sync_with_stdio
### 总结

1, 对比代码发现，利用现有的数据结构，可以快速出活，而且代码简洁，逻辑清晰。

2, STL不好好用，很慢。



## 494. 目标和 @2018/06/21

### jzf       

* 第一版 超时  复杂度 n*2^n
```c++
class Solution {
public:  int findTargetSumWays(vector<int>& nums, int S) {
    int n = 0;
    int sum = 0;
    int b = 0;
    int size =nums.size();
    for (size_t k = 0; k <size ; k++)
    {
        b = ((1 << k) | b);
    }
    for (size_t i = 0; i <= b; i++)
    {
        n = 0;
        for (size_t j = 0; j < size; j++)
        {
            n += ((1 << j)&i) ? -nums[j] : nums[j];
        }
        if (n == S)
        {
            sum++;
        }
    }
    return sum;
    }
};
```
* 第二版 

### kiritow  ：24ms  2
```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        if (S < -1000 || S>1000) return 0;

        int sz = nums.size();
        int msz = sizeof(int) * 2048;
        int _bin[2048] = { 0 };
        int _xbin[2048] = { 0 };
        int* p = _bin;
        int* q = _xbin;
        memset(p, 0, msz);
        p[1000] = 1;
        
        for (int i = 0; i < sz; i++)
        {
            memset(q, 0, msz);
            for (int j = 0; j < 2048; j++)
            {
                if (p[j])
                {
                    //printf("p[%d]=%d\n", p[j]);
                    // now=j-1000;
                    int L = j - nums[i]; // now-nums[i]+1000
                    int R = j + nums[i];
                    q[L] += p[j];
                    q[R] += p[j];
                    //printf("q[%d]=%d\n", L, q[L]);
                    //printf("q[%d]=%d\n", R, q[R]);
                }
            }
            std::swap(p, q);
        }
        return p[S + 1000];
    }
};
```

### 知识点
dfs

bfs

剪枝

记忆搜索

去掉重复

没写dp，身败名裂--惠惠语录

## 601. 体育馆的人流量@2018/06/21
### jzf :521ms  抄
```sql
    select s1.* 
    from stadium  as s1, stadium  as s2,stadium  as s3 
    where (((s2.id =s1.id+1) and (s3.id =s1.id+2))
           or((s2.id =s1.id-1) and (s3.id =s1.id+1))
           or((s2.id =s1.id-2) and (s3.id =s1.id-1)))
        and 
         (s1.people>=100 and s2.people>=100 and s3.people >=100)
    group by s1.id
```
### 知识点
mysql必知必会 16章 自连接
### 总结

1，看了下最快的sql语句，感叹逻辑差不过的东西，差距真大呀
## 9. 回文数@2018/06/22
### 羽柔子 372ms
```js
var isPalindrome = function(x) {
    return x.toString()===x.toString().split("").reverse().join("");
};
```
* 第二版 ：128ms
```c++
class Solution {
int list[10],len=0,i=0;
public:
    bool isPalindrome(int x) {
        if(x<0)return false;
        len=i=0;
        //分解
        while(true){
            if(x>=10){
                list[len++]=x%10;
                x/=10;
            }
            else{
                list[len++]=x;
                break;
            }
        }

        //判断
        --len;
        for(i=0;i<len&&list[i]==list[len];i++,len--);
        return i>=len;
    }
};
```
### jzf 
* 第一版 ：232ms
    ```c++
    class Solution {
    public:
        bool isPalindrome(int x) {
            int mod;
            int sh =x;
            vector<int> vec;
            if(x <0)
            {
                return false;
            }
            if(x ==0)
            {
                return true;
            }
            
            for(size_t i =0;sh>0;i++)
            {
                vec.push_back(sh%10);
                sh = sh/10;
            }
            vector<int>::iterator i=vec.begin();
            vector<int>::iterator j=vec.end()-1;
            for(;i<j;i++,j--)
            {
                if(*i!=*j)
                {
                    return false;
                }
            }
            return true;  
        }
    };
    ```
* 第2版 ：140ms
 ```c++
 class Solution {
public: bool isPalindrome(int x) {
        int mod;
        int sh =x;
        vector<int> vec;
        if(x <0)
        {
            return false;
        }
        if(x ==0)
        {
            return true;
        }
        if(x%10 ==0)
        {
            return false;
        }
        for(size_t i =0;sh>0;i++)
        {
            vec.push_back(sh%10);
            sh = sh/10;
        }
        vector<int>::iterator i=vec.begin();
        vector<int>::iterator j=vec.end()-1;
        for(;i<j;i++,j--)
        {
            if(*i!=*j)
            {
                return false;
            }
        }
        return true;  
    }
};
 ```
### 北河  244ms

* 第一版
```c++
class Solution {
public:
    bool isPalindrome(int x) {
        char p[10], q[10];
        short size = sprintf(p, "%d", x);
        reverse_copy(p, p + size, q);
        return x < 0 ? false : (mismatch(p, p + size / 2 + 1, q).first == (p + size / 2 + 1) ? true : false);               
    }
};
```
* 第二版
```c++
class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0) {
            return false;
        }
        string s = to_string(x);
        return mismatch(s.begin(), s.end(), s.rbegin()).first == s.end();
    }
};
```


### kiritow  120ms
```c++
#include <cstdio>
class Solution {
public:
    bool isPalindrome(int x) {
        /*
        // Converting to string is too slow!!
        char buff[64] = { 0 };
        sprintf(buff, "%d", x);
        int len = strlen(buff);
        int L = 0, R = len - 1;
        while (L < R)
        {
            if (buff[L] != buff[R]) return false;
            ++L;
            --R;
        }
        return true;
        */
        if (x < 0) return false;
        int buff[64] = { 0 };
        int c = 0;
        int tx = x;
        while (tx > 0)
        {
            buff[c++] = tx % 10;
            tx /= 10;
        }
        int L = 0, R = c - 1;
        while (L < R)
        {
            if (buff[L] != buff[R]) return false;
            ++L;
            --R;
        }
        return true;
    }
};
```
### puck 
```c++
#include <string>

class Solution
{
  public:
    bool isPalindrome(int x)
    {
        if (x < 0)
            return false;

        std::string tmp = std::to_string(x);

        std::size_t bi_size = tmp.size() / 2;
        auto half = tmp.begin() + bi_size;
        auto iter = tmp.begin();
        auto riter = tmp.rbegin();
        for (; iter != half; ++iter, ++riter)
        {
            if (*iter != *riter)
                return false;
        }
        return true;
    }
};
```
### 总结
1，
我在想一个问题
*羽柔子撤回了一条消息*
喵在想一个问题 --羽柔子语录
## 225. 用队列实现栈@2018/06/22

### 羽柔子 0ms
```c++
class MyStack {
    int stack[10],index=0;
    
public:
    /** Initialize your data structure here. */
    MyStack() {
    }
    
    /** Push element x onto stack. */
    void push(int x) {
        stack[index++]=x;
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        return stack[--index];
    }
    
    /** Get the top element. */
    int top() {
        return stack[index-1];
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return !index;
    }
};
```


